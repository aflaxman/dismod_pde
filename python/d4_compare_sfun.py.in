#! @PYTHON_PREFIX@/bin/python
# $begin d4_compare_sfun.py$$ $newlinech #$$
# $escape $$
# $spell
# 	pde
#	bc
#	solution solution
#	compare compare
#	py
#	rel_tol
#	Enum
#	dismod
#	csv
#	sfun
#	expr
#	omega
#	inf
# $$
#
# $section Compare sfun_out.csv and d4_simulate.py Solution File$$
#
# $head Syntax$$
# $codei%d4_compare_sfun.py        \
#	--sfun_out     %sfun_out.csv%  \
#	--solution     %solution.csv%  \
#	--compare      %compare.csv%   \
#	--include      %include_expr%  \
#	--value        %value_expr%    \
#	--median       %median_bound%  \
#	--average      %average_bound% \
#	--maximum      %maximum_bound%
# %$$
#
# $head Purpose$$
# This program outputs a comparison of the stochastic function values
# corresponding to a $cref d4_simulate.py$$ 
# solution file $icode solution.csv$$ and a $code dismod_pde_csv$$ 
# $cref/sfun_out.csv/dismod_pde_csv/sfun_out.csv/$$ result file.
#  
# $head sfun_out.csv$$
# This is an input file for $code d4_compare_sfun.py$$ that was generate by
# $code dismod_pde_csv$$; see $cref/sfun_out.csv/dismod_pde_csv/sfun_out.csv/$$.
#
# $head solution.csv$$
# This is an input file for $code d4_compare_sfun.py$$ that was generated by
# $code d4_simulate.py$$; 
# see $cref/d4_simulate.py/d4_simulate.py/solution.csv/$$.
# We use piecewise bilinear interpolator of the values
# in this solution file to obtain the values of the solution on 
# the same age-cohort grid as $icode sfun_out.csv$$.
# 
# $head compare.csv$$
# This is the output file generated by $code d4_compare_sfun.py$$
# with the same age-cohort grid as $icode sfun_out.csv$$.
# It is a $cref/dismod_pde csv file/csv/dismod_pde CSV Files/$$ with
# the following columns:
# $table
# $bold field$$  $pre  $$
# 	$cnext $bold Description$$ 
# $rnext
# $icode function$$ $pre  $$
# 	$cnext stochastic $cref/function/dismod_pde_csv/sfun_in.csv/function/$$; 
#	i.e., $code S$$, $code C$$, $code iota$$, $code rho$$, $code chi$$, or
#	$code omega$$.
# $rnext
# $icode age$$    $pre  $$
# 	$cnext age for the corresponding line in csv file, $latex a_j$$
# $rnext
# $icode cohort$$  $pre  $$
# 	$cnext cohort for the corresponding line in csv file, $latex c_k$$
# $rnext
# $icode time$$  $pre  $$
# 	$cnext time for the corresponding line in csv file, $latex a_k + c_k$$
# $rnext
# $icode solution$$ $pre  $$
#	$cnext interpolation of actual value used for simulation
#	from $icode solution.csv$$ to $latex s^q ( a_j , c_k )$$.
# $rnext
# $icode estimate$$ $pre  $$
#	$cnext the estimate in $icode sfun_out.csv$$ for $latex s_{j,k}^q$$.
# $rnext
# $icode value$$ $pre  $$
#	$cnext result of $cref/value_expr/d4_compare_sfun.py/value_expr/$$
#	for this row.
# $tend
# The output files is on the same grid as the $icode sfun_out.csv$$ file,
# and the values corresponding to the $icode solution.csv$$ file
# are interpolated to that grid.
#
# $head Expressions$$
# The following variables, corresponding to one row of the output file,
# are available for use in $icode include_expr$$ and $icode value_expr$$: 
# $code f$$ ($icode function$$),
# $code a$$ ($icode age$$), 
# $code c$$ ($icode cohort$$), 
# $code t$$ ($icode time$$), 
# $code s$$ ($icode solution$$), and
# $code e$$ ($icode estimate$$).
# In addition, $code inf$$ is equal to the value plus infinity,
# $code nan$$ is not a number, 
# $code True$$ is equal to true, and
# $code False$$ is equal to false.
# All of these variables are numeric, except for $icode f$$ which is a string.
# The expression is otherwise limited to the conditional expression syntax,
# the operators $code +$$, $code -$$, $code *$$, $code /$$, $code **$$,
# the $code max$$ and $code abs$$ functions, and numeric constants.
# 
# $head include_expr$$
# The result of the expression
# $icode include_expr$$ must be $code True$$ or $code False$$.
# If it is true, the corresponding row of the 
# output file $icode compare.csv$$ is included in the bound comparisons.
# For example, to include all results between 1950 and 2000, one could use
# $codep
#	-include '(1950 <= t) and (t <= 2000)'
# $$
# 
# $head value_expr$$
# The result of the expression
# $icode value_expr$$ must be a float that gets included in the comparisons
# (when $icode include_expr$$ is true).
# For example, to use the absolute relative error in the comparisons,
# one could use
# $codep
#	-value 'abs( (s - e) / s )' 
# $$
#
# $head median_bound$$
# is an upper bound for the median of $icode value_expr$$
# with respect to the rows where $icode include_expr$$ is true.
#
# $head average_bound$$
# is an upper bound for the average of $icode value_expr$$
# with respect to the rows where $icode include_expr$$ is true.
#
# $head maximum_bound$$
# is an upper bound for the maximum of $icode value_expr$$
# with respect to the rows where $icode include_expr$$ is true.
#
# $head Exit Status$$
# The return status is zero if every row of the output file is OK,
# otherwise the return status is one.
#
# $end
# --------------------------------------------------------------------------
import sys
import csv
import numpy
# --------------------------------------------------------------------------
# safe evalutation of expressions defined on the command line
def safe_eval(expr, f, a, c, t, s, e) :
	inf      = float('inf')
	loc = {
		'f' : f ,
		'a' : a , 
		'c' : c , 
		't' : t , 
		's' : s , 
		'e' : e , 
		'inf' : inf ,
		'nan' : float('nan') ,
		'True' : True ,
		'False' : False ,
		'max' : max , 
		'abs' : abs 
	}
	glo = {'__builtins__' : None}
	return eval(expr, glo, loc)
# --------------------------------------------------------------------------
usage = '''
usage: d4_compare_sfun.py \
	--sfun_out      sfun_out.csv 
	--solution      solution.csv 
	--compare       compare.csv 
	--include       include_expr
	--value         value_expr
	--median        median_bound
	--average       average_bound
	--maximum       maximum_bound

sfun_out.csv:     dismod_pde_csv stochastic function estimate file (input)
solution.csv:     stochastic funcition valuess during simulation (input)
compare.csv:      combintation of estimate and simulation values (output)
include_expr      if true, current row is used in bound comparisons
value_expr        if include_expr, value used in bound comparisons
median_bound      bound for the median of included value_expr values
average_bound     bound for the average of included value_expr values
maximum_bound     bound for the maximum of included value_expr values

expression can use f,a,c,t,s,e,+,-,*,/,**,max,abs.
'''
if len( sys.argv ) != 17 :
	print usage
	sys.exit('d4_compare_sfun.py: Error in command line')
#
sfun_out_done      = False
solution_done      = False
compare_done       = False
include_done       = False
value_done         = False
median_done        = False
average_done       = False
maximum_done       = False
#
arg                = sys.argv.__iter__()
program_name       = arg.next()
count_arg          = 1
while count_arg < 17 :
	flag      = arg.next()
	count_arg = count_arg + 2
	if flag == '--sfun_out' and not sfun_out_done :
		sfun_out_done = True
		sfun_out_csv  = arg.next()
	elif flag == '--solution' and not solution_done :
		solution_done = True
		solution_csv  = arg.next()
	elif flag == '--compare' and not compare_done :
		compare_done = True
		compare_csv  = arg.next()
	elif flag == '--include' and not include_done :
		include_done = True
		include_expr = arg.next()
	elif flag == '--value' and not value_done :
		value_done = True
		value_expr = arg.next()
	elif flag == '--median' and not median_done :
		median_done = True
		median_bound = float( arg.next() )
	elif flag == '--average' and not average_done :
		average_done = True
		average_bound = float( arg.next() )
	elif flag == '--maximum' and not maximum_done :
		maximum_done = True
		maximum_bound = float( arg.next() )
	else :
		msg = 'd4_compare_sfun.py: unknown flag = ' + flag
		print usage
		sys.exit(msg)
#
print 'd4_compare_sfuy.py: inputs'
print 'sfun_out_csv   = ', sfun_out_csv
print 'solution_csv   = ', solution_csv
print 'compare_csv    = ', compare_csv
print 'include_expr   = ', include_expr
print 'value_expr     = ', value_expr
print 'median_bound   = ', median_bound
print 'average_bound  = ', average_bound
print 'maximum_bound  = ', maximum_bound
#
# read the solution file
solution_fp      = open(solution_csv, 'r')
solution_reader  = csv.DictReader(solution_fp, skipinitialspace=True)
solution_list    = list( solution_reader )
solution_header = [ 'age', 'cohort', 'S', 'C', 'iota', 'rho', 'chi', 'omega' ]
#
# Solution file is on a rectangular grid. Determine n_age and the vector of 
# age values for  the solution file.
n_function = len( solution_header )
cohort     = solution_list[0]['cohort']
age        = []
n_age      = 0
age        = []
while solution_list[n_age]['cohort'] == cohort :
	age.append( float( solution_list[n_age]['age'] ) )
	n_age = n_age + 1
#
# Determine n_cohort and the vector of cohort values for the solution file
n_cohort   = len(solution_list) / n_age
cohort     = []
for index in range( len(solution_list) ) :
	row   = solution_list[index]
	if index % n_age == 0 :
		cohort.append( float( row['cohort'] ) )
	else :
		assert cohort[ int( index / n_age ) ] == float( row['cohort'] )  
#
# Create a numpy array with the solution values for stochastic functions.
n_stochastic  = len(solution_header) - 2
solution      = numpy.zeros( ( n_age , n_cohort, n_stochastic ) )
for j in range(n_age) :
	for k in range(n_cohort) :
		row = solution_list[ k * n_age + j  ] 
		for q in range(n_stochastic) :
			solution[j , k , q ] = row[ solution_header[ q + 2 ] ]
#
# mapping from stochastic function name to index in solution array
solution_index = { 
	'S' : 0 , 'C' : 1 , 'iota' : 2 , 'rho' : 3, 'chi' : 4, 'omega': 5 
}
# --------------------------------------------------------------------------
# reader for the estimate file
estimate_fp     = open(sfun_out_csv, 'r')
estimate_reader = csv.DictReader(estimate_fp, skipinitialspace=True)
# --------------------------------------------------------------------------
# writer for the comparision file
compare_fp      = open(compare_csv, 'w')
compare_writer  = csv.writer(compare_fp)
compare_header  = [ 
'age', 'cohort', 'time' , 'function', 'solution', 'estimate', 'include', 'value'
]
compare_writer.writerow(compare_header)
#
n_age2    = n_age - 2
j_below   = 0
a_below   = age[j_below]
a_above   = age[j_below+1]
#
n_cohort2 = n_cohort - 2
k_below   = 0
c_below   = cohort[k_below]
c_above   = cohort[k_below+1]
#
count_err  = 0
value_list = []
for r_in in estimate_reader :
	# determine the interval that surrounds a
	a      = float(r_in['age'])
	while j_below > 0 and a < a_below :
		j_below = j_below - 1
		a_above = a_below
		a_below = age[j_below]
	while j_below < n_age2 and a_above < a :
		j_below = j_below + 1
		a_below = a_above
		a_above = age[j_below + 1]
	# determine the interval that surrounds c
	c  = float(r_in['cohort'])
	while k_below > 0 and c < c_below :
		k_below = k_below - 1
		c_above = c_below
		c_below = cohort[k_below]
	while k_below < n_cohort and c_above < c :
		k_below = k_below + 1
		c_below = c_above
		c_above = cohort[k_below + 1]
	# now bilinearly interpolate solution to (a, c)
	da    = age[j_below+1]    - age[j_below]
	dc    = cohort[k_below+1] - cohort[k_below]
	rj    = (age[j_below+1]    - a) / da
	rk    = (cohort[k_below+1] - c) / dc
	rjp   =      (a - age[j_below]) / da
	rkp   =   (c - cohort[k_below]) / dc
	fun   = r_in['function']
	q     = solution_index[fun]
	sbar  = 0.
	sbar  = sbar + rj  * rk  * solution[j_below,   k_below,   q]
	sbar  = sbar + rjp * rk  * solution[j_below+1, k_below,   q]
	sbar  = sbar + rj  * rkp * solution[j_below,   k_below+1, q]
	sbar  = sbar + rjp * rkp * solution[j_below+1, k_below+1, q]
	estimate  = float( r_in['estimate'] )
	diff      = sbar - estimate
	t         = a + c
	s         = sbar
	e         = estimate
	include   = safe_eval(include_expr, fun, a, c, t, s, e)
	value     = safe_eval(value_expr, fun, a, c, t, s, e)
	if include :
		ok    = value <= maximum_bound
		value_list.append(value)
	else :
		ok    = True
	if not ok :
		count_err = count_err + 1
		f_str  = '%9s'   % fun
		a_str  = '%5d' % round(a)
		c_str  = '%7d' % round(c)
		t_str  = '%6d' % round(a + c)
		s_str  = '%10.1e' % s
		e_str  = '%10.1e' % e
		v_str  = '%11.2e' % value
		if count_err % 10 == 1 :
			fmt  = '%9s%5s%7s%6s%10s%10s%11s'
			name =(
				'function',
				'age',
				'cohort',
				'time',
				'simulate',
				'estimate',
				'value'
			)
			print fmt % name
		print f_str + a_str + c_str + t_str + s_str + e_str + v_str
	# now write out the comparision record
	time_str  = '%5d' % t
	sbar_str  = '%10.3e' % sbar
	value_str = '%10.3e' % value
	r_out = [ 
		r_in['age'], 
		r_in['cohort'], 
		time_str.strip(),
		fun.strip(),
		sbar_str.strip(),
		r_in['estimate'],
		include,
		value_str.strip()
	]
	compare_writer.writerow(r_out)
#
compare_fp.close()
estimate_fp.close()
solution_fp.close()
#
len_value  = len( value_list )
if len_value == 0 :
	sys.exit('compare_sfun.py: No values included in comparision')
max_value      = max( value_list )
avg_value      = sum( value_list ) / len_value
sort_value     = sorted( value_list )
if len_value % 2 == 0 :
	median_value   = sort_value[ int( len_value / 2 ) ]
else :
	index          = int(len_value / 2)
	median_value   = (sort_value[index] + sort_value[index+1]) / 2.
#
print 'd4_compare_sfuy.py: outputs'
print 'median_value = ', median_value 
print 'avg_value    = ', avg_value
print 'max_value    = ', max_value
#
if max_value > maximum_bound :
	sys.exit('compare_sfun.py: max_value > maximum_bound')
if avg_value > average_bound :
	sys.exit('compare_sfun.py: avg_value > average_bound')
if median_value > median_bound :
	sys.exit('compare_sfun.py: median_value > median_bound')
